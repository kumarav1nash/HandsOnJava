export const concepts = [
  {
    id: 'basics',
    title: 'Java Basics',
    summary: 'Variables, control flow, methods, and basic I/O.',
    overview: 'Learn Java syntax foundations: variables, types, conditionals, loops, methods, and basic I/O using Scanner and streams. Understand compilation and the main entry point.',
    tags: ['Basics'],
    difficulty: 'Beginner',
    starterCode: `public class Main {\n    public static void main(String[] args) {\n        System.out.println("Sum:" + (2 + 3));\n    }\n}`,
    steps: [
      {
        id: 'print-hello',
        description: 'Print "Hello, Java" to stdout.',
        stdin: '',
        expectedStdout: 'Hello, Java\n',
        hint: 'Use System.out.println("Hello, Java");',
      },
      {
        id: 'read-input',
        description: 'Read a word from stdin and echo it prefixed with Hi.',
        stdin: 'Alice\n',
        expectedStdout: 'Hi Alice\n',
        hint: 'Use Scanner and nextLine().',
      },
    ],
  },
  {
    id: 'oop',
    title: 'Object‑Oriented Programming',
    summary: 'Classes, objects, encapsulation, inheritance, and polymorphism.',
    overview: 'Explore OOP pillars: encapsulation via private fields and getters, inheritance for code reuse, and polymorphism through interfaces and method overriding.',
    tags: ['OOP'],
    difficulty: 'Beginner',
    starterCode: `class Greeter {\n    String greet(String name) { return "Hello, " + name; }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Greeter g = new Greeter();\n        System.out.println(g.greet("World"));\n    }\n}`,
    steps: [
      {
        id: 'encapsulation',
        description: 'Add a private field and a getter in Greeter.',
        stdin: '',
        expectedStdout: 'Hello, World\n',
        hint: 'Add private field message and expose getMessage().',
      },
    ],
  },
  {
    id: 'collections',
    title: 'Collections',
    summary: 'Lists, sets, maps, and iteration.',
    overview: 'Work with core collection types: List, Set, and Map. Learn iteration patterns and complexity trade‑offs. Practice counting frequencies and ordering results.',
    tags: ['Collections'],
    difficulty: 'Intermediate',
    starterCode: `import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3);\n        for (int n : nums) System.out.println(n);\n    }\n}`,
    steps: [
      {
        id: 'map-count',
        description: 'Count word frequencies from stdin using a Map.',
        stdin: 'a a b\n',
        expectedStdout: 'a=2\nb=1\n',
        hint: 'Use HashMap and split by spaces.',
      },
    ],
  },
  {
    id: 'streams',
    title: 'Streams',
    summary: 'Functional operations over collections.',
    overview: 'Use streams for declarative data processing: map, filter, reduce, and collectors. Learn when streams improve readability and how to avoid side effects.',
    tags: ['Streams'],
    difficulty: 'Intermediate',
    starterCode: `import java.util.*;\nimport java.util.stream.*;\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1,2,3,4);\n        int sum = nums.stream().mapToInt(i->i).sum();\n        System.out.println(sum);\n    }\n}`,
    steps: [
      {
        id: 'filter-even',
        description: 'Print only even numbers from stdin.',
        stdin: '1 2 3 4\n',
        expectedStdout: '2\n4\n',
        hint: 'Use filter(i -> i % 2 == 0).',
      },
    ],
  },
  {
    id: 'exceptions',
    title: 'Exceptions',
    summary: 'Try/catch, checked vs unchecked, and custom exceptions.',
    overview: 'Handle failures with try/catch, understand checked vs unchecked exceptions, and design clear error messages. Learn to create custom exceptions when semantics demand it.',
    tags: ['Exceptions'],
    difficulty: 'Intermediate',
    starterCode: `public class Main {\n    public static void main(String[] args) {\n        try {\n            int x = Integer.parseInt("42");\n            System.out.println(x);\n        } catch (NumberFormatException e) {\n            System.out.println("error");\n        }\n    }\n}`,
    steps: [
      {
        id: 'handle-parse',
        description: 'Safely parse stdin as int; print error on failure.',
        stdin: 'foo\n',
        expectedStdout: 'error\n',
        hint: 'Wrap parseInt in try/catch.',
      },
    ],
  },
  {
    id: 'generics',
    title: 'Generics',
    summary: 'Parameterize types and avoid casts.',
    overview: 'Use generics to express compile‑time safety and reusable data structures. Learn type parameters, wildcards, and bounds to eliminate casts and improve clarity.',
    tags: ['Generics'],
    difficulty: 'Intermediate',
    starterCode: `import java.util.*;\npublic class Main {\n    static <T> List<T> of(T a, T b) { return Arrays.asList(a,b); }\n    public static void main(String[] args) {\n        List<String> L = of("a","b");\n        for (String s : L) System.out.println(s);\n    }\n}`,
    steps: [
      {
        id: 'generic-box',
        description: 'Create a generic Box<T> with set/get.',
        stdin: '',
        expectedStdout: 'ok\n',
        hint: 'Define class Box<T> { T v; }',
      },
    ],
  },
  {
    id: 'concurrency',
    title: 'Concurrency',
    summary: 'Threads, executors, synchronization basics.',
    overview: 'Understand Java concurrency building blocks: Thread lifecycle, synchronization primitives, and the Executor framework for managing thread pools safely.',
    tags: ['Concurrency'],
    difficulty: 'Advanced',
    requiresCoding: false,
    starterCode: `public class Main {\n    public static void main(String[] args) throws Exception {\n        Thread t = new Thread(() -> System.out.println("Hi"));\n        t.start();\n        t.join();\n    }\n}`,
    steps: [
      {
        id: 'executor',
        description: 'Use ExecutorService to run two tasks printing lines.',
        stdin: '',
        expectedStdout: 'Task1\nTask2\n',
        hint: 'Use Executors.newFixedThreadPool(2).',
      },
    ],
  },
  {
    id: 'io',
    title: 'I/O',
    summary: 'Files, streams, and resource management.',
    overview: 'Read/write with streams, buffering, and resource safety via try‑with‑resources. Learn stdin/stdout patterns and file processing basics.',
    tags: ['I/O'],
    difficulty: 'Intermediate',
    starterCode: `import java.io.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine();\n        System.out.println(s);\n    }\n}`,
    steps: [
      {
        id: 'read-lines',
        description: 'Read two lines and print them reversed line by line.',
        stdin: 'a\nb\n',
        expectedStdout: 'b\na\n',
        hint: 'Store both lines then print in reverse order.',
      },
    ],
  },
  {
    id: 'threads-basics',
    title: 'Threads Basics',
    summary: 'Lifecycle, states, and simple Thread usage.',
    overview: 'Learn how to create and start threads, join them, and understand thread states. Practice printing from multiple threads and ensuring program termination with join().',
    tags: ['Concurrency', 'Threads'],
    difficulty: 'Beginner',
    starterCode: `public class Main {\n  public static void main(String[] args) throws Exception {\n    Thread t = new Thread(() -> System.out.println("Worker"));\n    t.start();\n    System.out.println("Main");\n    t.join();\n  }\n}`,
    steps: [
      { id: 'two-threads', description: 'Start two threads printing labels.', stdin: '', expectedStdout: 'T1\nT2\n', hint: 'Create two Thread instances and join both.' },
    ],
  },
  {
    id: 'sync-locks',
    title: 'Synchronization & Locks',
    summary: 'synchronized, reentrancy, and locking discipline.',
    overview: 'Use synchronized blocks/methods to protect shared state. Understand intrinsic locks (monitor) and reentrancy. Practice consistent lock acquisition to avoid races.',
    tags: ['Concurrency', 'Synchronization'],
    difficulty: 'Intermediate',
    starterCode: `public class Main {\n  static int counter = 0;\n  static synchronized void inc() { counter++; }\n  public static void main(String[] args) throws Exception {\n    Thread t1 = new Thread(() -> { for (int i=0;i<1000;i++) inc(); });\n    Thread t2 = new Thread(() -> { for (int i=0;i<1000;i++) inc(); });\n    t1.start(); t2.start(); t1.join(); t2.join();\n    System.out.println(counter);\n  }\n}`,
    steps: [
      { id: 'atomicity', description: 'Ensure atomic counter increments across threads.', stdin: '', expectedStdout: '2000\n', hint: 'Use synchronized or locks around increment.' },
    ],
  },
  {
    id: 'volatile-atomic',
    title: 'Volatile & Atomics',
    summary: 'Visibility and atomic operations.',
    overview: 'Learn the difference between visibility (volatile) and atomicity. Use AtomicInteger/AtomicLong for lock‑free increments when appropriate.',
    tags: ['Concurrency', 'Atomics'],
    difficulty: 'Intermediate',
    starterCode: `import java.util.concurrent.atomic.AtomicInteger;\npublic class Main {\n  static AtomicInteger ai = new AtomicInteger(0);\n  public static void main(String[] args) throws Exception {\n    Thread t1 = new Thread(() -> { for(int i=0;i<1000;i++) ai.incrementAndGet(); });\n    Thread t2 = new Thread(() -> { for(int i=0;i<1000;i++) ai.incrementAndGet(); });\n    t1.start(); t2.start(); t1.join(); t2.join();\n    System.out.println(ai.get());\n  }\n}`,
    steps: [
      { id: 'atomic-inc', description: 'Use AtomicInteger to reach exact count.', stdin: '', expectedStdout: '2000\n', hint: 'incrementAndGet is atomic.' },
    ],
  },
  {
    id: 'executors',
    title: 'Executors & Pools',
    summary: 'Fixed/thread pools and task submission.',
    overview: 'Use ExecutorService to manage task execution, lifecycle, and resource usage. Practice submit/invokeAll and proper shutdown.',
    tags: ['Concurrency', 'Executors'],
    difficulty: 'Intermediate',
    starterCode: `import java.util.concurrent.*;\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    ExecutorService es = Executors.newFixedThreadPool(2);\n    Future<String> f1 = es.submit(() -> "Task1");\n    Future<String> f2 = es.submit(() -> "Task2");\n    System.out.println(f1.get());\n    System.out.println(f2.get());\n    es.shutdown();\n  }\n}`,
    steps: [
      { id: 'submit-two', description: 'Submit two tasks and print their results.', stdin: '', expectedStdout: 'Task1\nTask2\n', hint: 'Collect futures and get() them.' },
    ],
  },
  {
    id: 'futures-completable',
    title: 'CompletableFuture',
    summary: 'Async composition and pipelines.',
    overview: 'Compose async tasks with CompletableFuture, using thenApply/thenCompose and allOf/anyOf. Learn non‑blocking patterns and exception handling.',
    tags: ['Concurrency', 'Futures'],
    difficulty: 'Advanced',
    starterCode: `import java.util.concurrent.*;\npublic class Main {\n  public static void main(String[] args) {\n    CompletableFuture<String> cf = CompletableFuture.supplyAsync(() -> "Hi");\n    String res = cf.thenApply(s -> s + " there").join();\n    System.out.println(res);\n  }\n}`,
    steps: [
      { id: 'compose', description: 'Compose two async steps and print final.', stdin: '', expectedStdout: 'Hi there\n', hint: 'Use thenApply/thenCompose and join().' },
    ],
  },
  {
    id: 'threadsafe-collections',
    title: 'Thread‑Safe Collections',
    summary: 'ConcurrentHashMap and concurrent queues.',
    overview: 'Use ConcurrentHashMap and concurrent queues for multi‑producer/consumer patterns. Learn performance and safety trade‑offs vs synchronized maps.',
    tags: ['Concurrency', 'Collections'],
    difficulty: 'Advanced',
    starterCode: `import java.util.concurrent.*;\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    ConcurrentMap<String,Integer> m = new ConcurrentHashMap<>();\n    ExecutorService es = Executors.newFixedThreadPool(2);\n    es.submit(() -> m.merge("a",1,Integer::sum));\n    es.submit(() -> m.merge("a",1,Integer::sum));\n    es.shutdown();\n    es.awaitTermination(1, TimeUnit.SECONDS);\n    System.out.println("a=" + m.get("a"));\n  }\n}`,
    steps: [
      { id: 'merge-safe', description: 'Update counts safely in multiple tasks.', stdin: '', expectedStdout: 'a=2\n', hint: 'Use merge or compute with ConcurrentHashMap.' },
    ],
  },
  {
    id: 'deadlock',
    title: 'Deadlocks & Ordering',
    summary: 'Avoid circular waits via lock ordering.',
    overview: 'Understand deadlocks, resource ordering, and avoidance strategies. Practice enforcing consistent lock order to prevent circular waits.',
    tags: ['Concurrency', 'Synchronization'],
    difficulty: 'Advanced',
    starterCode: `public class Main {\n  static final Object A = new Object();\n  static final Object B = new Object();\n  public static void main(String[] args) throws Exception {\n    Thread t1 = new Thread(() -> { synchronized(A){ synchronized(B){ System.out.println("T1"); } } });\n    Thread t2 = new Thread(() -> { synchronized(A){ synchronized(B){ System.out.println("T2"); } } });\n    t1.start(); t2.start(); t1.join(); t2.join();\n  }\n}`,
    steps: [
      { id: 'order-locks', description: 'Acquire locks in consistent order and print both.', stdin: '', expectedStdout: 'T1\nT2\n', hint: 'Always lock A then B in both threads.' },
    ],
  },
  {
    id: 'parallel-streams',
    title: 'Parallel Streams',
    summary: 'Data parallelism caveats and usage.',
    overview: 'Use parallel() with care; prefer stateless operations and avoid shared mutable state. Learn when parallel streams help and how ordering can differ.',
    tags: ['Concurrency', 'Streams'],
    difficulty: 'Advanced',
    starterCode: `import java.util.*;\nimport java.util.stream.*;\npublic class Main {\n  public static void main(String[] args) {\n    List<Integer> L = Arrays.asList(1,2,3,4);\n    int s = L.parallelStream().mapToInt(i->i).sum();\n    System.out.println(s);\n  }\n}`,
    steps: [
      { id: 'even-parallel', description: 'Filter even numbers in parallel and print.', stdin: '1 2 3 4\n', expectedStdout: '2\n4\n', hint: 'Use parallelStream().filter(...) and forEachOrdered for order.' },
    ],
  },
]

export function findConcept(id) {
  return concepts.find(c => c.id === id)
}