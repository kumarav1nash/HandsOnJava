id,title,statement,inputSpec,outputSpec,constraints,tags,isSample,input,expectedOutput
b001,Two Sum,"Given an integer array nums and an integer target, return indices i and j such that nums[i] + nums[j] == target. There is exactly one valid pair and you may not use the same element twice. Indices are 0-based; output as 'i j' with i < j. Duplicates may exist. Prefer O(n) using a hash map; sorting-based solutions are acceptable if they return original indices.","First line N, second line N space-separated integers, third line target","Two indices i j (0-based)","1 <= N <= 1e5","array,hashmap",true,"4\n2 5 7 11\n9","0 2\n"
b002,Best Time to Buy and Sell Stock,"Given an array prices where prices[i] is the price on day i, compute the maximum profit from a single transaction (buy once and sell later). If no profit is possible, return 0. Use O(n) time and O(1) space by tracking the minimum seen so far and the best profit.","First line N, second line N space-separated prices","Max profit (integer)","1 <= N <= 1e5","array,greedy",true,"6\n7 1 5 3 6 4","5\n"
b003,Contains Duplicate,"Given an integer array nums, return true if any value appears at least twice (i.e., there exists i != j such that nums[i] == nums[j]), otherwise false. Aim for O(n) expected time using a hash set; sorting to O(n log n) is acceptable.","First line N, second line N space-separated integers","true/false","1 <= N <= 1e5","array,hashset",true,"5\n1 2 3 1 5","true\n"
b004,Product of Array Except Self,"For an array nums, return output where output[i] is the product of all elements except nums[i] without using division. Achieve O(n) time and O(1) extra space (excluding the returned array) via prefix and suffix products. Handle zeros correctly (multiple zeros yield all zeros).","First line N, second line N space-separated integers","N space-separated integers","1 <= N <= 1e5","array,prefix-suffix",true,"4\n1 2 3 4","24 12 8 6\n"
b005,Maximum Subarray,"Return the maximum sum of any contiguous subarray of nums. Implement Kadane’s algorithm in O(n) time, tracking the current best ending here and the global best. The array may contain negative values.","First line N, second line N space-separated integers","Maximum sum (integer)","1 <= N <= 1e5","array,dp,kadane",true,"9\n-2 1 -3 4 -1 2 1 -5 4","6\n"
b006,Maximum Product Subarray,"Return the maximum product of a contiguous subarray. Because negatives can flip sign, track both the maximum and minimum products ending at each index and update answers accordingly. Solve in O(n) time.","First line N, second line N space-separated integers","Maximum product (integer)","1 <= N <= 1e5","array,dp",true,"4\n2 3 -2 4","6\n"
b007,Find Minimum in Rotated Sorted Array,"Given an ascending sorted array that was rotated at an unknown pivot (no duplicates), find and return the minimum element. Use binary search in O(log n) time by comparing mid with boundaries.","First line N, second line N space-separated integers","Minimum value (integer)","1 <= N <= 1e5","array,binary-search",true,"7\n4 5 6 7 0 1 2","0\n"
b008,Search in Rotated Sorted Array,"Search for target in a rotated strictly-increasing array without duplicates and return its index, or -1 if not found. Use modified binary search in O(log n) to determine which half is ordered.","First line N, second line N space-separated integers, third line target","Index (integer)","1 <= N <= 1e5","array,binary-search",true,"7\n4 5 6 7 0 1 2\n0","4\n"
b009,3Sum,"Given an integer array nums, find triplets (i,j,k) such that nums[i]+nums[j]+nums[k]==0 with i<j<k and no duplicate triplets. For this simplified output, return a single triplet sorted ascending if at least one exists; otherwise return empty. Use sorting and two-pointer technique in O(n^2).","First line N, second line N space-separated integers","Triplet as three space-separated integers sorted asc, or empty if none","1 <= N <= 1e5","array,two-pointers,sorting",true,"6\n-1 0 1 2 -1 -4","-1 0 1\n"
b010,Container With Most Water,"Given an array heights where heights[i] is the height at position i, pick two lines to form a container that holds the most water. Return the maximum area. Use two-pointer approach moving the shorter side inward to achieve O(n) time.","First line N, second line N space-separated integers","Max area (integer)","1 <= N <= 1e5","array,two-pointers",true,"9\n1 8 6 2 5 4 8 3 7","49\n"
b011,Sum of Two Integers,"Compute the sum of two integers a and b without using the + or - operators by applying bitwise operations (XOR for sum without carry, AND and shift for carry). For testing here, any correct method is accepted.","First line two space-separated integers","Sum (integer)","-1e9 <= a,b <= 1e9","bit-manipulation",true,"2 3","5\n"
b012,Number of 1 Bits,"Given a non-negative integer n, return the number of set bits (1s) in its binary representation (also known as Hamming weight). Consider using n &= (n - 1) to count efficiently.","One integer","Count (integer)","0 <= n <= 2^31-1","bit-manipulation",true,"11","3\n"
b013,Counting Bits,"Given integer n, return an array ans of length n+1 where ans[i] is the number of 1 bits in i for 0 <= i <= n. Use DP relations: ans[i] = ans[i >> 1] + (i & 1) to achieve O(n) time.","One integer n","Space-separated counts from 0..n","0 <= n <= 1e5","bit-manipulation,dp",true,"5","0 1 1 2 1\n"
b014,Missing Number,"An array of length n contains distinct numbers from 0..n with exactly one missing. Return the missing number. Solve with XOR, arithmetic sum, or index marking in O(n) time and O(1) extra space.","First line n, second line n space-separated integers","Missing number (integer)","1 <= n <= 1e5","array,math,bit-manipulation",true,"4\n3 0 1 4","2\n"
b015,Single Number,"In a non-empty array where every element appears exactly twice except for one, find the single occurrence element. Use bitwise XOR accumulation to achieve O(n) time and O(1) space.","First line N, second line N space-separated integers","Single number (integer)","1 <= N <= 1e5","array,bit-manipulation",true,"7\n4 1 2 1 2 4 6","6\n"
b016,Rotate Image,"Rotate an N x N matrix 90 degrees clockwise in-place and print the rotated matrix. Use either layer-by-layer 4-way swaps or transpose-then-reverse rows for O(N^2) time and O(1) extra space. Handle N=1 and any integer values; avoid allocating a full extra N x N matrix.","First line N, next N lines with N space-separated integers","Output N lines of rotated matrix","1 <= N <= 500","matrix",true,"3\n1 2 3\n4 5 6\n7 8 9","7 4 1\n8 5 2\n9 6 3\n"
b017,Spiral Matrix,"Output the elements of an R x C matrix in spiral order: traverse top row left-to-right, right column top-to-bottom, bottom row right-to-left, and left column bottom-to-top, shrinking bounds each layer. Works for rectangles as well as squares. Handle single row/column gracefully; return space-separated traversal.","First line R C, followed by R lines each with C space-separated integers","Space-separated traversal","1 <= R,C <= 200","matrix,simulation",true,"3 3\n1 2 3\n4 5 6\n7 8 9","1 2 3 6 9 8 7 4 5\n"
b018,Longest Substring Without Repeating Characters,"Compute the maximum length of a substring with all distinct characters. Use an O(n) sliding window with a map of last-seen indices; move the left bound past duplicates to maintain uniqueness. Treat characters literally; return an integer. Edge cases: empty string -> 0.","One line string s","Length (integer)","|s| <= 1e5","string,sliding-window,hashmap",true,"abcabcbb","3\n"
b019,Longest Repeating Character Replacement,"Return the maximum length of a substring that can be made of the same character after replacing up to k characters. Use sliding window tracking per-character counts and the window’s max frequency; expand while window_size - max_freq <= k. Handles uppercase/lowercase; edge case: k=0.","First line string s, second line integer k","Length (integer)","|s| <= 1e5","string,sliding-window",true,"AABABBA\n1","4\n"
b020,Valid Anagram,"Return true if t is an anagram of s (same character counts). Prefer O(n) frequency counting; sorting both strings also works. Immediately return false when lengths differ. Treat characters as-is (case-sensitive); produce literal 'true' or 'false'.","Two lines: s then t","true/false","|s|,|t| <= 1e5","string,hashmap,sorting",true,"anagram\nnagaram","true\n"
b021,Group Anagrams,"Group words that are anagrams. Within each group, sort words lexicographically. Order groups by ascending group size, then by the group’s first word to match sample output. Use a canonical key per word (sorted letters or frequency signature). Output format: [group1];[group2]... with group words space-separated.","First line N, second line N space-separated words","Groups as: [group1];[group2]... where group words space-separated","1 <= N <= 1e4","string,hashmap",true,"6\neat tea tan ate nat bat","bat;nat tan;ate eat tea\n"
b022,Valid Parentheses,"Return true if the bracket string is properly nested. Allowed brackets: (), [], {}. Use a stack: push openings; on closings, check the top for a matching pair and pop. Valid iff all matches succeed and the stack is empty at end.","One line string s","true/false","|s| <= 1e5","string,stack",true,"()[]{}","true\n"
b023,Valid Palindrome,"Return true if s is a palindrome considering only alphanumeric characters and ignoring case. Use two pointers skipping non-alphanumerics via Character.isLetterOrDigit and compare case-insensitively. Empty or single-character strings are palindromes.","One line string s","true/false","|s| <= 1e5","string,two-pointers",true,"A man, a plan, a canal: Panama","true\n"
b024,Longest Palindromic Substring,"Return the longest palindromic substring; if multiple, choose the earliest occurrence. Use expand-around-center (odd and even centers) in O(n^2) time or Manacher’s algorithm for O(n). Input length up to 2000.","One line string s","Substring","|s| <= 2e3","string,expand-center,dp",true,"babad","bab\n"
b025,Palindromic Substrings,"Count all palindromic substrings (each occurrence is counted). Use expand-around-center for both odd and even centers; O(n^2) time is acceptable for |s| <= 2000. Return the count as an integer.","One line string s","Count (integer)","|s| <= 2e3","string,expand-center,dp",true,"aaa","6\n"
b026,Merge Two Sorted Lists,"Merge two ascending sorted linked lists into one ascending list. Use a standard two-pointer merge; handle empty lists. Output the merged list’s values space-separated.","First line N1, second line N1 integers; third line N2, fourth line N2 integers","Space-separated integers","1 <= N1,N2 <= 1e5","linked-list,two-pointers",true,"3\n1 2 4\n3\n1 3 4","1 1 2 3 4 4\n"
b027,Remove Nth From End,"Remove the N-th node from the end using a single pass with two pointers separated by k steps. Handle removing the head when k equals the list length. Output remaining values space-separated.","First line N, second line N space-separated integers, third line k","Space-separated integers","1 <= N <= 1e5","linked-list,two-pointers",true,"5\n1 2 3 4 5\n2","1 2 3 5\n"
b028,Add Two Numbers,"Add two non-negative integers represented in reverse-order linked lists; output the sum list in reverse order. Iterate with carry across unequal lengths and add a final carry node if needed. Output space-separated digits.","First line N1, second line N1 ints; third line N2, fourth line N2 ints","Space-separated result list","1 <= N1,N2 <= 1e5","linked-list,math",true,"3\n2 4 3\n3\n5 6 4","7 0 8\n"
b029,Linked List Cycle,"Detect whether a cycle exists in the linked list. For testing, an index 'pos' indicates the tail connects to the node at 'pos' (or -1 for no cycle). Use Floyd’s tortoise-hare pointers; return 'true' if a cycle exists else 'false'.","First line N, second line N space-separated integers, third line pos (index of tail connecting to pos or -1)","true/false","1 <= N <= 1e5","linked-list,two-pointers",true,"3\n3 2 0 -4\n1","true\n"
b030,Intersection of Two Linked Lists,"Find the node where two singly linked lists intersect by reference (not by value). For testing, we provide the intersection value if any; output that value or -1 if no intersection. Standard approach uses pointer switching to align list lengths.","Two lines: list A and list B space-separated; third line intersection value or -1","Intersection value or -1","|A|,|B| <= 1e5","linked-list,two-pointers",true,"4 1 8 4 5\n4 6 1 8 4 5\n8","8\n"
b031,Invert Binary Tree,"Invert (mirror) a binary tree by swapping left/right children recursively or via BFS. Output level-order including 'null' placeholders for missing nodes. Ensure traversal preserves shape after inversion; large inputs should avoid recursion depth issues.","One line level-order nodes space-separated (null for missing)","One line level-order of inverted tree","Nodes <= 1e5","tree,bfs,dfs",true,"4 2 7 1 3 6 9","7 2 9 3 1 null null\n"
b032,Maximum Depth of Binary Tree,"Compute the maximum depth (height) using DFS or BFS. Treat 'null' as empty nodes when building the tree from level-order. Depth of empty tree is 0; single node is 1.","One line level-order nodes space-separated (null for missing)","Depth (integer)","Nodes <= 1e5","tree,dfs,bfs",true,"3 9 20 null null 15 7","3\n"
b033,Same Tree,"Return 'true' if two trees are structurally identical with equal node values. Compare recursively (values and left/right) or iteratively via queues. Level-order inputs may include 'null' placeholders.","Two lines: level-order for tree A; level-order for tree B","true/false","Nodes <= 1e5","tree,dfs",true,"1 2 3\n1 2 3","true\n"
b034,Subtree of Another Tree,"Return 'true' if B is a subtree of A: some node in A has a subtree exactly equal to B. Use serialization + KMP or recursive match (isSame + traverse). Build trees from level-order (with 'null').","Two lines: level-order A; level-order B","true/false","Nodes <= 1e5","tree,dfs",true,"3 4 5 1 2 null null null null 0","false\n"
b035,Binary Tree Level Order Traversal,"Return level-wise nodes using BFS; print each level’s values space-separated, and separate levels by ';'. Ignore 'null' placeholders when printing nodes per level.","One line level-order input","Levels as: level1;level2;... with nodes space-separated","Nodes <= 1e5","tree,bfs",true,"3 9 20 null null 15 7","3;9 20;15 7\n"
b036,Binary Tree Right Side View,"Return the last (rightmost) node from each level when viewed from the right. BFS with level boundaries or DFS preferring right children first both work.","One line level-order input","Space-separated nodes","Nodes <= 1e5","tree,bfs,dfs",true,"1 2 3 null 5 null 4","1 3 4\n"
b037,Validate BST,"Return 'true' if the tree satisfies BST property: left < root < right for all nodes. Use DFS with min/max bounds or inorder traversal checking strict increase.","One line level-order input","true/false","Nodes <= 1e5","tree,bst,dfs",true,"2 1 3","true\n"
b038,Kth Smallest in BST,"Return the kth smallest value using inorder traversal (BST yields sorted order). Handle nulls in level-order when building the tree; k is 1-indexed.","First line k, second line level-order input","Value (integer)","Nodes <= 1e5","tree,bst,inorder",true,"2\n5 3 6 2 4 null null 1","3\n"
b039,Lowest Common Ancestor of BST,"Use BST property: walk down from root; if both p and q < root go left; if both > root go right; else root is LCA. Build tree from level-order with nulls.","First line two values p q, second line level-order input","Value (integer)","Nodes <= 1e5","tree,bst",true,"2 8\n6 2 8 0 4 7 9 null null 3 5","6\n"
b040,Construct Tree from Preorder and Inorder,"Reconstruct the binary tree using preorder (root-first) and inorder arrays with an index map for O(n). Then output the postorder traversal space-separated.","First line N, second line preorder, third line inorder","Space-separated postorder","N <= 1e5","tree,construction,hashmap",true,"6\n3 9 20 15 7 8\n9 3 15 20 7 8","9 15 8 7 20 3\n"
b041,Top K Frequent Elements,"Return the k most frequent elements. Sort by frequency descending, then value ascending for ties. Use a frequency map and sort unique values or a heap; output k values space-separated.","First line N, second line N integers, third line k","Space-separated k elements","1 <= N <= 1e5","array,heap,hashmap",true,"6\n1 1 1 2 2 3\n2","1 2\n"
b042,K Closest Points to Origin,"Return k points with smallest Euclidean distance to origin. Sort by distance ascending; break ties by x then y. Use a max-heap of size k or full sort; print one 'x y' per line.","First line N, second line k, then N lines 'x y'","k lines 'x y'","1 <= N <= 1e5","geometry,heap",true,"3\n2\n1 3\n-2 2\n5 8","-2 2\n1 3\n"
b043,Task Scheduler,"Given tasks (characters) and cooldown n, return minimum intervals to finish all tasks with idle slots allowed. Use formula: max(totalTasks, (maxFreq-1)*(n+1) + countMaxFreq).","First line N tasks as chars space-separated, second line cooldown n","Intervals (integer)","1 <= tasks <= 1e5","array,greedy,math,hashmap",true,"6\nA A A B B B\n2","8\n"
b044,Subsets,"Generate all subsets (power set) via backtracking or bitmask enumeration. Sort elements and output subsets lexicographically; delimit subsets with ';'. Represent the empty subset as an empty string between semicolons.","First line N, second line N integers","Subsets as semicolon-delimited lists (each list space-separated)","N <= 15","backtracking",true,"3\n1 2 3","; ;1;2;3;1 2;1 3;2 3;1 2 3\n"
b045,Combination Sum,"Find all unique combinations that sum to target; candidates may be reused. Backtrack with non-decreasing order to avoid duplicates. Sort output combinations and numbers within each; delimit by ';'.","First line N, second line N integers, third line target","Semicolon-delimited combinations","N <= 30","backtracking",true,"4\n2 3 6 7\n7","7;2 2 3\n"
b046,Permutations,"Generate all permutations of the given list using backtracking or next-permutation. Sort the output lexicographically; print each permutation as space-separated values, and delimit permutations with ';'.","First line N, second line N integers","Semicolon-delimited permutations","N <= 8","backtracking",true,"3\n1 2 3","1 2 3;1 3 2;2 1 3;2 3 1;3 1 2;3 2 1\n"
b047,Word Search,"Return 'true' if the word exists by traversing adjacent cells (up/down/left/right) without reusing a cell in the same path. Use DFS with backtracking; prune early when mismatch.","First line R C, then R lines each with C chars (no spaces), then word","true/false","R,C <= 12","backtracking,dfs",true,"3 4\nABCE\nSFCS\nADEE\nSEE","true\n"
b048,Palindrome Partitioning,"Partition the string into all lists of palindromic substrings using backtracking with palindrome DP (optional). Sort partitions lexicographically; within each partition, words are space-separated and groups are separated by '|'; delimit partitions with ';'.","One line string s","Partitions delimited by ';' and groups by '|'","|s| <= 16","backtracking,string,dp",true,"aab","a a|aa;a|a a\n"
b049,Letter Combinations of a Phone Number,"Map digits [2–9] to letters and generate all combinations via DFS/backtracking. Sort combinations lexicographically; output space-separated.","One line digits","Space-separated combinations","|digits| <= 10","backtracking,string",true,"23","ad ae af bd be bf cd ce cf\n"
b050,N-Queens,"Count distinct solutions placing n queens so none attack each other. Use backtracking with column/diag sets or bitmasks for performance.","One integer n","Count (integer)","1 <= n <= 14","backtracking",true,"4","2\n"
b051,Course Schedule,"Given numCourses and prerequisite pairs 'a b' meaning b->a, determine if all courses can be finished (i.e., the graph is acyclic). Detect cycles using DFS with color marking or Kahn’s algorithm in O(N+M). Output literal 'true' or 'false'.","First line numCourses, second line M (edges), next M lines 'a b' meaning b->a","true/false","|edges| <= 1e5","graph,topological-sort,dfs,bfs",true,"2\n2\n1 0\n0 1","false\n"
b052,Course Schedule II,"Produce any valid topological ordering of courses given prerequisites 'a b' meaning b->a; if a cycle exists, output empty. Use Kahn’s algorithm (BFS with indegrees) or DFS postorder. Output space-separated indices.","First line numCourses, second line M, next M lines 'a b' meaning b->a","Space-separated course order or empty","|edges| <= 1e5","graph,topological-sort,bfs,dfs",true,"4\n4\n1 0\n2 0\n3 1\n3 2","0 1 2 3\n"
b053,Pacific Atlantic Water Flow,"Compute all cells from which water can flow to both the Pacific and Atlantic oceans. Run reverse BFS/DFS from each ocean’s border (non-decreasing heights) to mark reachability, then intersect sets. Output coordinates sorted by row then col, semicolon-delimited as 'r c'.","First line R C, then R lines heights","Semicolon-delimited 'r c'","R,C <= 200","graph,dfs,bfs,matrix",true,"5 5\n1 2 2 3 5\n3 2 3 4 4\n2 4 5 3 1\n6 7 1 4 5\n5 1 1 2 4","0 4;1 3;1 4;2 2;3 0;3 1;4 0\n"
b054,Number of Islands,"Count connected components of land ('1') using DFS/BFS in 4 directions. Mark visited cells to avoid recounting; treat '0' as water. Return the total number of islands.","First line R C, then R lines of 0/1 as chars","Count (integer)","R,C <= 1000","graph,dfs,bfs,matrix",true,"4 5\n11000\n11000\n00100\n00011","3\n"
b055,Longest Consecutive Sequence,"Return the length of the longest run of consecutive integers. Use a hash set and start only at numbers with no predecessor (x-1 not in set), extending forward to compute the run length in O(n).","First line N, second line N integers","Length (integer)","N <= 1e5","array,hashset",true,"6\n100 4 200 1 3 2","4\n"
b056,Graph Valid Tree,"A graph is a tree iff it is connected and has exactly N-1 edges with no cycles. Verify using Union-Find or DFS/BFS (track visited and detect cycles). Return literal 'true' or 'false'.","First line N nodes, second line M edges, next M lines 'u v'","true/false","N <= 1e5","graph,union-find,bfs,dfs",true,"5\n4\n0 1\n0 2\n0 3\n1 4","true\n"
b057,Min Cost to Connect All Points,"Compute the minimum spanning tree (MST) total cost where edge weights are Manhattan distance |x1-x2|+|y1-y2|. Use Prim’s algorithm with a min-heap for O(N^2) typical constraints, or Kruskal with optimized edge generation. Output the integer total cost.","First line N, then N lines 'x y'","Total cost (integer)","N <= 1e5","graph,mst,prim,heap",true,"4\n0 0\n2 2\n3 10\n5 2","16\n"
b058,Insert Interval,"Insert a new interval into a sorted list and merge any overlaps. Sort by start, then combine overlapping ranges to produce non-overlapping intervals. Output semicolon-delimited 'l r' sorted by start.","First line N, next N lines 'l r'; last line new 'l r'","Semicolon-delimited intervals 'l r'","N <= 1e5","intervals",true,"3\n1 3\n6 9\n8 10\n2 5","1 5;6 10\n"
b059,Merge Intervals,"Sort intervals by start and merge overlaps to produce a minimal set of non-overlapping intervals. Output semicolon-delimited ranges sorted by start.","First line N, next N lines 'l r'","Semicolon-delimited intervals","N <= 1e5","intervals",true,"4\n1 3\n2 6\n8 10\n15 18","1 6;8 10;15 18\n"
b060,Non-overlapping Intervals,"Select the maximum number of non-overlapping intervals by sorting by end time (greedy). The minimum removals equal total intervals minus selected count. Output the removal count as an integer.","First line N, next N lines 'l r'","Removals (integer)","N <= 1e5","intervals,greedy",true,"4\n1 2\n2 3\n3 4\n1 3","1\n"
b061,Meeting Rooms,"Determine if any intervals overlap after sorting by start times. If any meeting’s start is less than the previous meeting’s end, overlapping occurs -> return 'false'; otherwise return 'true'.","First line N, next N lines 'start end'","true/false","N <= 1e5","intervals",true,"3\n0 30\n5 10\n15 20","false\n"
b062,Meeting Rooms II,"Compute the minimum rooms required by tracking concurrent meetings. Use a min-heap of end times or sweep line over starts/ends to find the maximum overlap count.","First line N, next N lines 'start end'","Rooms (integer)","N <= 1e5","intervals,heap",true,"3\n0 30\n5 10\n15 20","2\n"
b063,Coin Change,"Return the fewest coins to reach the target using bottom-up DP. Initialize dp[0]=0 and dp[x]=min(dp[x-c]+1) over coins c; if unreachable, output -1.","First line N, second line N coin values, third line amount","Minimum coins (integer)","amount <= 1e4","dp",true,"3\n1 2 5\n11","3\n"
b064,Longest Increasing Subsequence,"Return the length of the LIS using patience sorting (maintain tails and binary search) in O(n log n), or classic O(n^2) DP for smaller inputs.","First line N, second line N integers","Length (integer)","N <= 1e5","dp,binary-search",true,"8\n10 9 2 5 3 7 101 18","4\n"
b065,Longest Common Subsequence,"Compute the LCS length via DP over indices: dp[i][j] = dp[i-1][j-1]+1 if s[i-1]==t[j-1] else max(dp[i-1][j], dp[i][j-1]). Return the integer length.","Two lines strings s and t","Length (integer)","|s|,|t| <= 1e3","dp,string",true,"abcde\nace","3\n"
b066,Word Break,"Return 'true' if s can be segmented into dictionary words using DP. dp[i] is true if there exists j<i with dp[j] and s[j..i) in the dictionary. Use a HashSet for O(1) lookups.","First line s, second line N, third line N words","true/false","|s| <= 1e5","dp,string,hashset",true,"leetcode\n2\nleet code","true\n"
b067,Combination Sum IV,"Count ordered combinations to reach target using DP: dp[t] = sum(dp[t-num]) over nums with dp[0]=1. Order matters; ensure iteration over target increasing. Return the total count.","First line N, second line N integers, third line target","Count (integer)","N <= 200, target <= 1000","dp",true,"3\n1 2 3\n4","7\n"
b068,House Robber,"Maximize sum without adjacent picks using DP: keep prev1 (best up to i-1) and prev2 (best up to i-2). Transition: newPrev1 = max(prev1, prev2 + nums[i]). Return final prev1.","First line N, second line N integers","Max sum (integer)","N <= 1e5","dp",true,"4\n1 2 3 1","4\n"
b069,Decode Ways,"Count decodings with DP handling zeros: dp[i]=0 if s[i]=='0' unless '10' or '20'. Otherwise dp[i]=dp[i-1] + dp[i-2] when the two-digit number is 10..26. Return total ways.","One line digits string","Count (integer)","|s| <= 1e5","dp,string",true,"226","3\n"
b070,Unique Paths,"Move only right or down from (0,0) to (m-1,n-1). Compute using DP or combinatorics C(m+n-2, m-1). Return the count as an integer.","Two integers m n","Count (integer)","m,n <= 100","dp,math",true,"3 7","28\n"
b071,Jump Game,"Greedily track the farthest reachable index while scanning. If the current index exceeds the farthest reach, return 'false'; otherwise update reach and finish with 'true' if last index is reachable.","First line N, second line N integers","true/false","N <= 1e5","array,greedy",true,"5\n2 3 1 1 4","true\n"
b072,Climbing Stairs,"Count distinct ways with steps of 1 or 2 using Fibonacci DP: ways[n]=ways[n-1]+ways[n-2] with base ways[0]=1, ways[1]=1. Return ways[n].","One integer n","Count (integer)","n <= 45","dp",true,"5","8\n"
b073,Binary Search,"Search target in a sorted array using iterative binary search (left/right pointers, mid). Return index if found, else -1. Use O(log n) time.","First line N, second line sorted N integers, third line target","Index (integer)","N <= 1e5","array,binary-search",true,"6\n-1 0 3 5 9 12\n9","4\n"
b074,Merge Sorted Array,"Merge nums2 into nums1 in non-decreasing order using two pointers from the end to avoid overwriting. Output the final merged array space-separated.","First line N M, second line N ints (with M zeros at end), third line M ints","Space-separated merged array","N,M <= 1e5","array,two-pointers",true,"6 3\n1 2 3 0 0 0\n2 5 6","1 2 2 3 5 6\n"
b075,Valid Sudoku,"Validate a 9x9 Sudoku: each row, column, and 3x3 sub-box must contain digits 1–9 without repetition ('.' denotes empty). Track seen digits per row/col/box; return literal 'true' or 'false'.","Nine lines each with 9 chars '.' or digits","true/false","Fixed 9x9","matrix,validation",true,"5 3 . . 7 . . . .\n6 . . 1 9 5 . . .\n. 9 8 . . . . 6 .\n8 . . . 6 . . . 3\n4 . . 8 . 3 . . 1\n7 . . . 2 . . . 6\n. 6 . . . . 2 8 .\n. . . 4 1 9 . . 5\n. . . . 8 . . 7 9","true\n"